// vim: syntax=c

#include "requestHandler.h"
#include "StringStorage.h"
#include "testUtils.h"
#include "OdfTree.h"
#include <stdio.h>

char actualResponse[2048]; // max response size for tests
char * bufferLocation = actualResponse;
int saveActualResponse(const char * format, ...) {
  va_list argptr;
  va_start(argptr, format);
  int ret = vsprintf(bufferLocation, format, argptr);
  if (ret > 0) bufferLocation += ret;
  return 0;
}

Printf get(int i) {
  (void) i;
  return saveActualResponse;
}

#define ResetBuffer() bufferLocation = actualResponse; bufferLocation[0] = '\0'
#define AssertResponseEquals(expected) \
  ck_assert_str_eq(actualResponse, (expected)); \
  ResetBuffer()

#suite requestHandler

#test handleWriteReadT
    OmiParser pa;
    OmiParser *p = &pa;
    OmiParser_init(p, 0);
    p->odfCallback = handleRequestPath;
    p->parameters = (OmiRequestParameters){
      .requestType = OmiWrite,
      .version = OmiV2_ns,
      .arrival = 1000,
      .deadline = 1010
      };
    connectionHandler.getPrintfForConnection = get;
    StringStorage_init();
    OdfTree_init(&tree);
    Path* path;
    OdfTree odf;
    OdfTree_init(&odf);
    OdfParserEvent e = OdfParserEvent(PE_Path, NULL);
    
    ck_assert_str_eq(tree.sortedPaths[0].odfId, "Objects");
    path = addPath(&odf, "Objects");
    ck_assert_int_eq(handleWrite(p, path, e), Err_OK);
    
    OmiParser_pushPath(p, "MyObject", 0);
    ck_assert_str_eq(tree.sortedPaths[1].odfId, "MyObject");
    OmiParser_pushPath(p, "MyItem", PF_IsInfoItem);
    ck_assert_str_eq(tree.sortedPaths[2].odfId, "MyItem");
    ck_assert_int_eq(tree.size, 3);
    //handleWrite(p, p->currentOdfPath, OdfParserEvent(PE_Path, NULL));


    // error cases
    path = addPath(&odf, "Objects/Fail");
    stringStorage.alloc = &nullocator;
    ck_assert_int_eq(handleWrite(p, path, e), Err_OOM_String);
    ck_assert_int_eq(tree.size, 3);

    stringStorage.alloc = &stdAllocator;
    path = addPath(&odf, "Objects/UnknownParent/Fail2");
    ck_assert_int_eq(handleWrite(p, path, e), Err_InternalError);
    ck_assert_int_eq(tree.size, 3);

    path = addPath(&odf, "Objects/MyObject/Fail3");
    path->flags |= PF_IsInfoItem;
    int freeCount = LatestValues.freeCount;
    LatestValues.freeCount = 0;
    ck_assert_int_eq(handleWrite(p, path, e), Err_OOM);
    LatestValues.freeCount = freeCount;
    ck_assert_int_eq(tree.size, 3);

    path = addPath(&odf, "Objects/MyObject/Fail4");
    tree.capacity = 3;
    ck_assert_int_eq(handleWrite(p, path, e), Err_OOM);
    ck_assert_int_eq(tree.size, 3);
    tree.capacity = ODFTREE_SIZE;

    path = addPath(&odf, "Objects/MyObject/Fail5");
    e = OdfParserEvent(PE_ValueData, stra("garbage"));
    ck_assert_int_eq(handleWrite(p, path, e), Err_InternalError);
    ck_assert_int_eq(tree.size, 3);

    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_RequestID, stra("garbage"))), Err_InvalidElement);

    // Values
    int resultIndex = 0;
    path = addPath(&odf, "Objects/MyObject/description");
    path->flags |= PF_IsDescription | PF_ValueMalloc;
    // Quick error cases here
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueUnixTime, stra("10"))), Err_InternalError);
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueDateTime, stra("10"))), Err_InternalError);
    // The real description
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_Path, stra("My description"))), Err_OK);
    ck_assert(odfBinarySearch(&tree, path, &resultIndex));
    ck_assert_str_eq(tree.sortedPaths[resultIndex].value.str, "My description");
    
    path = addPath(&odf, "Objects/MyObject/MyItem");
    path->flags |= V_String | PF_IsInfoItem;
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueUnixTime, stra("1234567"))), Err_OK);
    ck_assert(odfBinarySearch(&tree, path, &resultIndex));
    ck_assert_int_eq(tree.sortedPaths[resultIndex].value.latest->upcoming.timestamp, 1234567);
    // replaces the date
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueDateTime, stra("1970-01-01T12:10:10Z"))), Err_OK);
    ck_assert_int_lt(tree.sortedPaths[resultIndex].value.latest->upcoming.timestamp, 80000); // FIXME: System timezones affect the result

    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueType, stra("my_random_type"))), Err_OK);
    ck_assert_int_eq(path->flags & PF_ValueType, V_String);

    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueData, stra("my value"))), Err_OK);
    ck_assert_str_eq(tree.sortedPaths[resultIndex].value.latest->current.value.str, "my value");
    char * oldValue = tree.sortedPaths[resultIndex].value.latest->current.value.str;
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueData, stra("my new value"))), Err_OK);
    ck_assert_str_eq(tree.sortedPaths[resultIndex].value.latest->current.value.str, "my new value");
    free(oldValue); // FIXME: temporary free before handleDelete is implemented
    free(tree.sortedPaths[resultIndex].value.latest->current.value.str);

    path->flags |= V_Int | PF_IsInfoItem;
    path->value.i = 20;
    handleWrite(p, path, OdfParserEvent(PE_ValueUnixTime, stra("1234567")));
    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_ValueData, NULL)), Err_OK);
    ck_assert_int_eq(tree.sortedPaths[resultIndex].value.latest->current.value.i, 20);
    ck_assert(tree.sortedPaths[resultIndex].value.latest->current.value.l == 20L);


    // misc
    p->parameters.requestType = OmiInvalid;
    ck_assert_int_eq(handleRequestPath(p, path, OdfParserEvent(PE_RequestID, stra("garbage"))), Err_NotImplemented);

    ck_assert_int_eq(handleWrite(p, path, OdfParserEvent(PE_RequestEnd, NULL)), Err_OK);
    AssertResponseEquals(
      "<omiEnvelope xmlns=\"http://www.opengroup.org/xsd/omi/2.0/\" version=\"2.0\" ttl=\"10\">"
      "<response><result><return returnCode=\"200\"/></result></response></omiEnvelope>"); //valid
    // Not possible at the moment but needs to be tested:
    handleWrite(p, path, OdfParserEvent(PE_RequestEnd, stra("garbage")));
    ResetBuffer();


    // Read
    path = addPath(&odf, "Objects");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    AssertResponseEquals(
      "<omiEnvelope xmlns=\"http://www.opengroup.org/xsd/omi/2.0/\" version=\"2.0\" ttl=\"10\">"
      "<response><result msgformat=\"odf\"><return returnCode=\"200\"/><msg>"
      "<Objects xmlns=\"http://www.opengroup.org/xsd/odf/2.0/\" version=\"2.0\">"
    );
    handleRead(p, NULL, OdfParserEvent(PE_RequestEnd, NULL));
    AssertResponseEquals(
      "<Object><id>MyObject</id>"
      "<InfoItem name=\"MyItem\">"
      "<value unixTime=\"1234567\" type=\"xs:int\">20</value></InfoItem>"
      //"<description>My description</description>"
      "</Object>"
      "</Objects></msg></result></response></omiEnvelope>"
    );

    // Add one extra item at current level
    OmiParser_popPath(p);
    OmiParser_pushPath(p, "MyItem2", PF_IsInfoItem);
    handleWrite(p, p->currentOdfPath, OdfParserEvent(PE_ValueUnixTime, stra("1234567")));
    handleWrite(p, p->currentOdfPath, OdfParserEvent(PE_ValueData, stra("my value")));
    // Add one extra object at the same level
    OmiParser_popPath(p);
    OmiParser_pushPath(p, "MySubObject", 0);
    handleWrite(p, p->currentOdfPath, OdfParserEvent(PE_Path, NULL));
    // Add one extra object at upper level
    OmiParser_popPath(p);
    OmiParser_popPath(p);
    OmiParser_pushPath(p, "MyObject2", 0);
    handleWrite(p, p->currentOdfPath, OdfParserEvent(PE_Path, NULL));
    ResetBuffer();

    p->lastPath = NULL;
    path = addPath(&odf, "Objects");
    handleRead(p, path, OdfParserEvent(PE_Path, stra("ignored")));
    path = addPath(&odf, "Objects/MyObject");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    path = addPath(&odf, "Objects/MyObject/MyItem");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    path = addPath(&odf, "Objects/MyObject2");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    handleRead(p, NULL, OdfParserEvent(PE_RequestEnd, stra("ignored")));
    AssertResponseEquals(
      "<omiEnvelope xmlns=\"http://www.opengroup.org/xsd/omi/2.0/\" version=\"2.0\" ttl=\"10\">"
      "<response><result msgformat=\"odf\"><return returnCode=\"200\"/><msg>"
      "<Objects xmlns=\"http://www.opengroup.org/xsd/odf/2.0/\" version=\"2.0\">"
      "<Object><id>MyObject</id>"
      "<InfoItem name=\"MyItem\">"
      "<value unixTime=\"1234567\" type=\"xs:int\">20</value></InfoItem>"
      "</Object>"
      "</Objects></msg></result></response></omiEnvelope>"
    );

    // invalid event, via handleRequestPath
    p->parameters.requestType = OmiRead;
    ck_assert_int_eq(handleRequestPath(p, NULL, OdfParserEvent(PE_ValueData, stra("ignored"))), Err_InternalError);

    //description
    p->lastPath = NULL;
    path = addPath(&odf, "Objects");
    // via handleRequestPath
    handleRead(p, path, OdfParserEvent(PE_Path, stra("ignored")));
    path = addPath(&odf, "Objects/MyObject");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    path = addPath(&odf, "Objects/MyObject/description");
    handleRead(p, path, OdfParserEvent(PE_Path, NULL));
    handleRead(p, NULL, OdfParserEvent(PE_RequestEnd, stra("ignored")));
    AssertResponseEquals(
      "<omiEnvelope xmlns=\"http://www.opengroup.org/xsd/omi/2.0/\" version=\"2.0\" ttl=\"10\">"
      "<response><result msgformat=\"odf\"><return returnCode=\"200\"/><msg>"
      "<Objects xmlns=\"http://www.opengroup.org/xsd/odf/2.0/\" version=\"2.0\">"
      "<Object><id>MyObject</id>"
      "<description>My description</description>"
      "</Object>"
      "</Objects></msg></result></response></omiEnvelope>"
    );


    //Allocator latestValueFreer = (Allocator){.free = LatestValue_destroy};
    //OdfTree_destroy(&tree, &stdAllocator, &latestValueFreer);
    OdfTree_destroy(&tree, &stdAllocator, &LatestValuesAllocator);
    OmiParser_destroy(p);

